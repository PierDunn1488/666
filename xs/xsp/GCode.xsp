%module{Slic3r::XS};

%{
#include <xsinit.h>
#include "libslic3r/GCode.hpp"
#include "libslic3r/GCode/CoolingBuffer.hpp"
<<<<<<< HEAD
<<<<<<< HEAD
#include "libslic3r/GCode/SpiralVase.hpp"
=======
>>>>>>> origin/merill-merge
=======
>>>>>>> origin/merill-merge
%}

%name{Slic3r::GCode::CoolingBuffer} class CoolingBuffer {
    CoolingBuffer(GCode* gcode)
        %code{% RETVAL = new CoolingBuffer(*gcode); %};
    ~CoolingBuffer();
    Ref<GCode> gcodegen();
    std::string process_layer(std::string gcode, size_t layer_id);
<<<<<<< HEAD
};

%name{Slic3r::GCode::CoolingBuffer} class CoolingBuffer {
    CoolingBuffer(GCode* gcode)
        %code{% RETVAL = new CoolingBuffer(*gcode); %};
    ~CoolingBuffer();
    Ref<GCode> gcodegen();
    
    std::string append(std::string gcode, std::string obj_id, size_t layer_id, float print_z);
    std::string flush();
};

%name{Slic3r::GCode::SpiralVase} class SpiralVase {
    SpiralVase(StaticPrintConfig* config)
        %code{% RETVAL = new SpiralVase(*dynamic_cast<PrintConfig*>(config)); %};
    ~SpiralVase();
    
    bool enable()
        %code{% RETVAL = THIS->enable; %};
    void set_enable(bool enable)
        %code{% THIS->enable = enable; %};
    std::string process_layer(std::string gcode);
=======
>>>>>>> origin/merill-merge
};

%name{Slic3r::GCode} class GCode {
    GCode();
    ~GCode();
    void do_export(Print *print, const char *path)
        %code%{
            try {
                THIS->do_export(print, path);
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};

    Ref<Vec2d> origin()
        %code{% RETVAL = &(THIS->origin()); %};
    void set_origin(Vec2d* pointf)
        %code{% THIS->set_origin(*pointf); %};
    Ref<Point> last_pos()
        %code{% RETVAL = &(THIS->last_pos()); %};

    unsigned int    layer_count() const;
    void            set_layer_count(unsigned int value);
    void            set_extruders(std::vector<unsigned int> extruders) 
        %code{% THIS->writer().set_extruders(extruders); THIS->writer().set_extruder(0); %};

    void apply_print_config(StaticPrintConfig* print_config)
        %code{%
            if (const PrintConfig* config = dynamic_cast<PrintConfig*>(print_config)) {
                THIS->apply_print_config(*config);
            } else {
                CONFESS("A PrintConfig object was not supplied to apply_print_config()");
            }
        %};
<<<<<<< HEAD
<<<<<<< HEAD
    void set_extruders(std::vector<unsigned int> extruder_ids);
    void set_origin(Pointf* pointf)
        %code{% THIS->set_origin(*pointf); %};
    std::string preamble();
    std::string notes();
    std::string change_layer(Layer* layer)
        %code{% RETVAL = THIS->change_layer(*layer); %};
    %name{extrude_loop} std::string extrude(ExtrusionLoop* loop, std::string description = "", double speed = -1)
        %code{% RETVAL = THIS->extrude(*loop, description, speed); %};
    %name{extrude_path} std::string extrude(ExtrusionPath* path, std::string description = "", double speed = -1)
        %code{% RETVAL = THIS->extrude(*path, description, speed); %};
    std::string travel_to(Point* point, ExtrusionRole role, std::string comment)
        %code{% RETVAL = THIS->travel_to(*point, role, comment); %};
    bool needs_retraction(Polyline* travel, ExtrusionRole role = erNone)
        %code{% RETVAL = THIS->needs_retraction(*travel, role); %};
    std::string retract(bool toolchange = false);
    std::string unretract();
    std::string set_extruder(unsigned int extruder_id);
    Clone<Pointf3> get_cog();
    std::string cog_stats();
    Clone<Pointf> point_to_gcode(Point* point)
        %code{% RETVAL = THIS->point_to_gcode(*point); %};

%{
std::string
GCode::extrude(entity, description, speed)
    SV*         entity
    std::string description;
    double      speed;
    CODE:
        ExtrusionEntity* e = (ExtrusionEntity *)SvIV((SV*)SvRV( entity ));
        RETVAL = THIS->extrude(*e, description, speed);
    OUTPUT:
        RETVAL
%}
=======
>>>>>>> origin/merill-merge
=======
>>>>>>> origin/merill-merge

    Ref<StaticPrintConfig> config()
        %code{% RETVAL = const_cast<StaticPrintConfig*>(static_cast<const StaticPrintConfig*>(static_cast<const PrintObjectConfig*>(&THIS->config()))); %};
};
