%module{Slic3r::XS};

%{
#include <xsinit.h>
#include "libslic3r/Print.hpp"
#include "libslic3r/PlaceholderParser.hpp"
%}

%package{Slic3r::Print::State};
%{

IV
_constant()
  ALIAS:
    STEP_LAYERS             = posLayers
    STEP_SLICE              = posSlice
    STEP_PERIMETERS         = posPerimeters
    STEP_DETECT_SURFACES    = posDetectSurfaces
    STEP_PREPARE_INFILL     = posPrepareInfill
    STEP_INFILL             = posInfill
    STEP_SUPPORTMATERIAL    = posSupportMaterial
    STEP_SKIRT              = psSkirt
    STEP_BRIM               = psBrim
    STEP_WIPE_TOWER         = psWipeTower
  PROTOTYPE:
  CODE:
    RETVAL = ix;
  OUTPUT: RETVAL

%}

%name{Slic3r::Print::Region} class PrintRegion {
    // owned by Print, no constructor/destructor

    Ref<StaticPrintConfig> config()
        %code%{ RETVAL = &THIS->config(); %};
    Ref<Print> print();
    
    Clone<Flow> flow(FlowRole role, double layer_height, bool bridge, bool first_layer, double width, PrintObject* object)
        %code%{ RETVAL = THIS->flow(role, layer_height, bridge, first_layer, width, *object); %};
};

%name{Slic3r::Print::Object} class PrintObject {
    // owned by Print, no constructor/destructor

    int region_count()
        %code%{ RETVAL = THIS->print()->regions().size(); %};

    Ref<Print> print();
    Ref<ModelObject> model_object();
    Ref<StaticPrintConfig> config()
<<<<<<< HEAD
<<<<<<< HEAD
        %code%{ RETVAL = &THIS->config; %};
    Points copies();
    t_layer_height_ranges layer_height_ranges()
        %code%{ RETVAL = THIS->layer_height_ranges; %};
    Ref<LayerHeightSpline> layer_height_spline()
        %code%{ RETVAL = &THIS->layer_height_spline; %};
    Ref<Point3> size()
        %code%{ RETVAL = &THIS->size; %};
    Clone<BoundingBox> bounding_box();
    Ref<Point> _copies_shift()
        %code%{ RETVAL = &THIS->_copies_shift; %};
    std::vector<int> support_material_extruders()
        %code%{
            std::set<size_t> extruders = THIS->support_material_extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
        %};
    std::vector<int> extruders()
        %code%{
            std::set<size_t> extruders = THIS->extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
        %};
=======
        %code%{ RETVAL = &THIS->config(); %};
    Clone<BoundingBox> bounding_box();
>>>>>>> origin/merill-merge
    
    size_t layer_count();
    Ref<Layer> get_layer(int idx);
<<<<<<< HEAD
    Ref<Layer> add_layer(int id, coordf_t height, coordf_t print_z,
        coordf_t slice_z);
    void delete_layer(int idx);
    %name{support_material_flow} Clone<Flow> _support_material_flow(FlowRole role = frSupportMaterial);
=======
=======
        %code%{ RETVAL = &THIS->config(); %};
    Clone<BoundingBox> bounding_box();
    
    size_t layer_count();
    Ref<Layer> get_layer(int idx);
>>>>>>> origin/merill-merge

>>>>>>> origin/merill-merge
    size_t support_layer_count();
    Ref<SupportLayer> get_support_layer(int idx);
<<<<<<< HEAD
<<<<<<< HEAD
    Ref<SupportLayer> add_support_layer(int id, coordf_t height, coordf_t print_z);
    void delete_support_layer(int idx);
    
    bool invalidate_step(PrintObjectStep step);
    bool invalidate_all_steps();
    bool step_done(PrintObjectStep step)
        %code%{ RETVAL = THIS->state.is_done(step); %};
    void set_step_done(PrintObjectStep step)
        %code%{ THIS->state.set_done(step); %};
    void set_step_started(PrintObjectStep step)
        %code%{ THIS->state.set_started(step); %};
    
    void detect_surfaces_type();
    void process_external_surfaces();
    void bridge_over_infill();
    void combine_infill();
    void discover_horizontal_shells();
    void clip_fill_surfaces();
    void slice();
    void _slice();
    SV* _slice_region(size_t region_id, std::vector<double> z, bool modifier)
        %code%{
            std::vector<float> z_f(z.begin(), z.end());
            std::vector<ExPolygons> layers = THIS->_slice_region(region_id, z_f, modifier);
            AV* layers_av = newAV();
            size_t len = layers.size();
            if (len > 0) av_extend(layers_av, len-1);
            for (unsigned int i = 0; i < layers.size(); i++) {
                AV* expolygons_av = newAV();
                len = layers[i].size();
                if (len > 0) av_extend(expolygons_av, len-1);
                unsigned int j = 0;
                for (ExPolygons::iterator it = layers[i].begin(); it != layers[i].end(); ++it) {
                    av_store(expolygons_av, j++, perl_to_SV_clone_ref(*it));
                }
                av_store(layers_av, i, newRV_noinc((SV*)expolygons_av));
            }
            RETVAL = (SV*)newRV_noinc((SV*)layers_av);
        %};
    void make_perimeters();
    void prepare_infill();
    void infill();
    void _simplify_slices(double distance);
    
    int ptr()
        %code%{ RETVAL = (int)(intptr_t)THIS; %};
};
=======
>>>>>>> origin/merill-merge
=======
>>>>>>> origin/merill-merge

    bool step_done(PrintObjectStep step)
        %code%{ RETVAL = THIS->is_step_done(step); %};

    void slice();
};

%name{Slic3r::Print} class Print {
    Print();
    ~Print();

    Ref<Model> model()
        %code%{ RETVAL = const_cast<Model*>(&THIS->model()); %};
    Ref<StaticPrintConfig> config()
        %code%{ RETVAL = const_cast<GCodeConfig*>(static_cast<const GCodeConfig*>(&THIS->config())); %};
    Ref<PlaceholderParser> placeholder_parser()
        %code%{ RETVAL = const_cast<PlaceholderParser*>(&THIS->placeholder_parser()); %};
    Ref<ExtrusionEntityCollection> skirt()
        %code%{ RETVAL = const_cast<ExtrusionEntityCollection*>(&THIS->skirt()); %};
    Ref<ExtrusionEntityCollection> brim()
        %code%{ RETVAL = const_cast<ExtrusionEntityCollection*>(&THIS->brim()); %};
//    std::string estimated_normal_print_time()
//        %code%{ RETVAL = THIS->print_statistics().estimated_normal_print_time; %};
//    std::string estimated_silent_print_time()
//        %code%{ RETVAL = THIS->print_statistics().estimated_silent_print_time; %};
    double total_used_filament()
        %code%{ RETVAL = THIS->print_statistics().total_used_filament; %};
    double total_extruded_volume()
        %code%{ RETVAL = THIS->print_statistics().total_extruded_volume; %};
    double total_weight()
        %code%{ RETVAL = THIS->print_statistics().total_weight; %};
    double total_cost()
        %code%{ RETVAL = THIS->print_statistics().total_cost; %};
    double total_wipe_tower_cost()
        %code%{ RETVAL = THIS->print_statistics().total_wipe_tower_cost; %};
    double total_wipe_tower_filament()
        %code%{ RETVAL = THIS->print_statistics().total_wipe_tower_filament; %};
    int wipe_tower_number_of_toolchanges()
        %code%{ RETVAL = THIS->wipe_tower_data().number_of_toolchanges; %};
    PrintObjectPtrs* objects()
        %code%{ RETVAL = const_cast<PrintObjectPtrs*>(&THIS->objects()); %};
    Ref<PrintObject> get_object(int idx)
        %code%{ RETVAL = THIS->objects()[idx]; %};
    size_t object_count()
        %code%{ RETVAL = THIS->objects().size(); %};

    PrintRegionPtrs* regions()
        %code%{ RETVAL = const_cast<PrintRegionPtrs*>(&THIS->regions()); %};
    Ref<PrintRegion> get_region(int idx)
        %code%{ RETVAL = THIS->regions()[idx]; %};
    size_t region_count()
        %code%{ RETVAL = THIS->regions().size(); %};
    
<<<<<<< HEAD
<<<<<<< HEAD
    bool invalidate_step(PrintStep step);
    bool invalidate_all_steps();
=======
>>>>>>> origin/merill-merge
=======
>>>>>>> origin/merill-merge
    bool step_done(PrintStep step)
        %code%{ RETVAL = THIS->is_step_done(step); %};
    bool object_step_done(PrintObjectStep step)
        %code%{ RETVAL = THIS->is_step_done(step); %};
    
<<<<<<< HEAD
<<<<<<< HEAD
    std::vector<int> object_extruders()
        %code%{
            std::set<size_t> extruders = THIS->object_extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
        %};
    std::vector<int> support_material_extruders()
        %code%{
            std::set<size_t> extruders = THIS->support_material_extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
        %};
    std::vector<int> extruders()
        %code%{
            std::set<size_t> extruders = THIS->extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
        %};
    int brim_extruder();
    void clear_filament_stats()
        %code%{
            THIS->filament_stats.clear();
        %};
    void set_filament_stats(int extruder_id, float length)
        %code%{
            THIS->filament_stats.insert(std::pair<size_t,float>(extruder_id, 0));
            THIS->filament_stats[extruder_id] += length;
        %};
=======
>>>>>>> origin/merill-merge
=======
>>>>>>> origin/merill-merge
    SV* filament_stats()
        %code%{
            HV* hv = newHV();
            for (std::map<size_t,float>::const_iterator it = THIS->print_statistics().filament_stats.begin(); it != THIS->print_statistics().filament_stats.end(); ++it) {
                // stringify extruder_id
                std::ostringstream ss;
                ss << it->first;
                std::string str = ss.str();
                
                (void)hv_store( hv, str.c_str(), str.length(), newSViv(it->second), 0 );
                RETVAL = newRV_noinc((SV*)hv);
            }
        %};
    double max_allowed_layer_height() const;
    bool has_support_material() const;
    void auto_assign_extruders(ModelObject* model_object);
<<<<<<< HEAD
<<<<<<< HEAD
    std::string output_filename();
    std::string output_filepath(std::string path = "");
    
    void add_model_object(ModelObject* model_object, int idx = -1);
    bool apply_config(DynamicPrintConfig* config)
        %code%{ RETVAL = THIS->apply_config(*config); %};
    bool apply_static_config(StaticPrintConfig* config)
        %code%{
            DynamicPrintConfig dpc;
            dpc.apply(*config);
            RETVAL = THIS->apply_config(dpc);
        %};
    bool has_infinite_skirt();
    bool has_skirt();
    std::string _validate()
        %code%{
            try {
                THIS->validate();
            } catch (std::exception &e) {
                RETVAL = e.what();
            }
        %};
    Clone<BoundingBox> bounding_box();
    Clone<BoundingBox> total_bounding_box();
    double skirt_first_layer_height();
    Clone<Flow> brim_flow();
    Clone<Flow> skirt_flow();
    void make_skirt();
    void _make_brim();
%{
=======
    std::string output_filepath(std::string path = "")
        %code%{
            try {
                RETVAL = THIS->output_filepath(path);
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};
=======
    std::string output_filepath(std::string path = "")
        %code%{
            try {
                RETVAL = THIS->output_filepath(path);
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};
>>>>>>> origin/merill-merge
        
    bool apply(Model *model, DynamicPrintConfig* config)
        %code%{ 
            // Touching every config as the Perl bindings does not correctly export ModelConfig,
            // therefore the configs have often invalid timestamps.
            for (auto obj : model->objects) {
                obj->config.touch();
                for (auto vol : obj->volumes)
                    vol->config.touch();
            }
            for (auto mat : model->materials)
                mat.second->config.touch();
            RETVAL = THIS->apply(*model, *config);
        %};
    bool has_infinite_skirt();
    std::vector<unsigned int> extruders() const;
    int validate() %code%{ 
            std::string err = THIS->validate(); 
            if (! err.empty())
                croak("Configuration is not valid: %s\n", err.c_str()); 
            RETVAL = 1;
        %};
<<<<<<< HEAD
>>>>>>> origin/merill-merge

    void set_callback_event(int evt) %code%{
        %};
    void set_status_silent();
    void set_status(int percent, const char *message);

    void process() %code%{
            try {
                THIS->process();
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};

    void export_gcode(char *path_template) %code%{
            try {
                THIS->export_gcode(path_template, nullptr);
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};

<<<<<<< HEAD

double
Print::total_weight(...)
    CODE:
        if (items > 1) {
            THIS->total_weight = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_weight;
    OUTPUT:
        RETVAL

double
Print::total_cost(...)
    CODE:
        if (items > 1) {
            THIS->total_cost = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_cost;
    OUTPUT:
        RETVAL

%}
=======
>>>>>>> origin/merill-merge
=======

    void set_callback_event(int evt) %code%{
        %};
    void set_status_silent();
    void set_status(int percent, const char *message);

    void process() %code%{
            try {
                THIS->process();
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};

    void export_gcode(char *path_template) %code%{
            try {
                THIS->export_gcode(path_template, nullptr);
            } catch (std::exception& e) {
                croak("%s\n", e.what());
            }
        %};

>>>>>>> origin/merill-merge
};
